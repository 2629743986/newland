<%  set_title("collection.find") %>
<%  set_layout("doc_layout.html") %>
<h3>collection.find</h3>
<p>此方法会根据最后一个参数是否为回调函数决定是同步方法或还异步方法，如果是异步方法，那么回调的第二个参数则是cursor对象。
    同步方法不用说也是cursor对象
</p>
<br/>
<p>find方法支持传入多个对象作为过滤条件得到我们想要的结果，如果想得到所有数据，可以什么都不传或只传个空对象</p>
<pre class="brush:javascript;gutter:false;toolbar:false">
 var cursor = db.users.find({})
 var cursor = db.users.find()
</pre>
<br/>
<p>我们可以根据对象某个属性进行过滤.</p>
<pre class="brush:javascript;gutter:false;toolbar:false">
 var cursor = db.users.find({'last_name': 'Smith'})
</pre>
<p>并且这个查询对象将作为返回cursor的selector属性。</p>
<p>返回只包含一条记录的cursor.</p>
<pre class="brush:javascript;gutter:false;toolbar:false">
 var cursor = db.users.findOne()
</pre>
<br/>
<p>limit:对返回记录数进行限制</p>
<pre class="brush:javascript;gutter:false;toolbar:false">
 var cursor = db.users.find({'msg':'Hello 1'}).limit(10)
//或者
var cursor = db.users.find({'msg':'Hello 1'},{"limit":10})
</pre>
<br/>
<p>skip:跳跃到已得到的结果某一条中,配合上面limit可以轻易实现分页功能.</p>
<pre class="brush:javascript;gutter:false;toolbar:false">
page1 = db.things.find().limit(20)
page2 = db.things.find().skip(20).limit(20)
page3 = db.things.find().skip(40).limit(20)
//更简单的写法
page3 = db.things.find({}, {}, 20, 40);

</pre>
<p>注:当数据量很大时，skip操作会变的很慢，应该避免使用。（不止是mongoDb会这样，大部分数据库都是。）
   可以通过改变查询文档的规则来达到分页效果，避免使用skip来跳过大量的数据。通过计算，得到下次查询应该从什么地方开始
</p>
<br/>
<p>sort排序</p>
<pre class="brush:javascript;gutter:false;toolbar:false">
 var cursor = db.users.find({'email':'ixigua@sina.com'}).sort({'Dt',-1})
//或者
var cursor =  db.users.find({'email':'ixigua@sina.com'},{"sort":{'Dt',-1}} )
//上面的-1表示倒序
var cursor =  db.users.find({'email':'ixigua@sina.com'},{"sort":"Dt"} )
</pre>
<br/>
<p>count操作，返回匹配的记录数</p>
<pre class="brush:javascript;gutter:false;toolbar:false">
 db.user_addr.count()
</pre>
<p>distinct操作，对记录进行去重</p>
<pre class="brush:javascript;gutter:false;toolbar:false">
 db.users.distinct('msg')
 </pre>
<br/>
<p>对数值类型的属性可以通过比较大小的操作进行过滤</p>
<pre class="brush:javascript;gutter:false;toolbar:false">
db.collection.find({ "field" : { $gt: value } } );   // greater than  : field > value
db.collection.find({ "field" : { $lt: value } } );   // less than  :  field < value
db.collection.find({ "field" : { $gte: value } } );  // greater than or equal to : field >= value
db.collection.find({ "field" : { $lte: value } } );  // less than or equal to : field <=
</pre>
<p>还可以复合使用</p>
<pre class="brush:javascript;gutter:false;toolbar:false">
db.collection.find({ "field" : { $gt: value1, $lt: value2 } } );
</pre>
<br/>
<p>$exists操作：判断字段是否存在 </p>
<p>查询所有存在name字段的记录 </p>
<pre class="brush:javascript;gutter:false;toolbar:false">
db.users.find({name: {$exists: true}});
</pre>
<p>查询所有不存在phone字段的记录 </p>
<pre class="brush:javascript;gutter:false;toolbar:false">
db.users.find({phone: {$exists: false}});
</pre> 
<br/>
<p>$all,匹配所有 </p>
<pre class="brush:javascript;gutter:false;toolbar:false">
db.users.find({favorite_number : {$all : [6, 8]}});
</pre>
<p>查询出{name: 'David', age: 26, favorite_number: [ 6, 8, 9 ] } </p>
<p>过滤掉{name: 'David', age: 26, favorite_number: [ 6, 7, 9 ] } </p>
<br/>
<p>$not,不匹配</p>
<p>查询不匹配name=B*带头的记录 </p>
<pre class="brush:javascript;gutter:false;toolbar:false">
db.users.find({name: {$not: /^B.*/}});
</pre>
<p>查询 age取模10不等于0 的数据 </p>
<pre class="brush:javascript;gutter:false;toolbar:false">
db.users.find({age : {$not: {$mod : [10, 0]}}});
</pre>
<p>$where查询 </p>
<pre class="brush:javascript;gutter:false;toolbar:false">
//查询 age > 18 的记录，以下查询都一样
db.users.find({age: {$gt: 18}});
db.users.find({$where: "this.age > 18"});
db.users.find("this.age > 18");
var f = function() {return this.age > 18} db.users.find(f);
</pre>
<p>根据子对象的属性查询</p>
<pre class="brush:javascript;gutter:false;toolbar:false">
db.users.find({age : {$not: {$mod : [10, 0]}}});
</pre>
<p>$type判断字段类型 </p>
<pre class="brush:javascript;gutter:false;toolbar:false">
//查询所有name字段是字符类型的
db.users.find({name: {$type: 2}});
//查询所有age字段是整型的
db.users.find({age: {$type: 16}});
</pre>

http://www.mongodb.org/display/DOCS/Advanced+Queries